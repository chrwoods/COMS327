This package includes six programs: mapbuild.c, pathfind.c, mapandpath.c, monstermap.c, and ncursed.c.

mapbuild.c: This program generates and prints a 80x21 map based on the specifications given in the assignment 1.01, namely containing at least 6 rooms that are at least 4x3 in size that are all connected by corridors. A random map can be generated by calling the program (./mapgen) without any parameters, and it can also be called with a seed.

This program supports using three flags, any other arguments will throw an error:

--load: This loads the map from a file named "dungeon" in the .rlg327/ directory in the user's home directory. This uses a special file structure outlined in the 1.02 assignment spec, which among other things gives the room grid with rock hardnesses, and room, stairs, and player character locations.

--save: This saves the map that was either generated randomly, generated from a given seed, or loaded from the dungeon file, into the same location that the load_map function loads to.

--seed <seed number>: This gives the map generator a seed to generate from instead of generating randomly. The argument after the --seed flag can be any integer, and if it is negative it will generate randomly.

Any and all of these flags can be used simultaneously, however using --seed in conjunction with --load will render the --seed function useless, as a map isn't being generated. --load and --save together will read the given dungeon file and save a file that will output the exact same dungeon, so it exists more for a "hey did this student do this right so I can give them points" perspective for the TAs reading this file.

pathfind.c: This program loads the map from the "dungeon" file in the .rlg327/ directory in the user's home directory and generates and prints two 80x21 pathing maps. The first one represents the distance from the player character for a nontunneling monster, so walls are impossible to pass through, and moving from each cell takes one unit. The second one represents the distance from the player character from a tunneling monster, so walls take their hardness/85 plus one units to move through, and rooms and corridors take one unit. These maps are calculated using the one and only Dijkstra's method.

mapandpath.c: This program does what both of the previous programs do at once. It can use any and all of the flags that mapbuild.c can, and in addition to printing out the generated/loaded map, will also print out the two pathing maps that pathfind.c generates. It also generates 10 monsters and simulates 20 turns of monster movement.

monstermap.c: This program simulates an actual game, doing what all previous programs do plus game flow. It uses all flags as before plus the --nummon <number> flag, which allows the manual setting of the number of monsters instead of the default 10. This runs the game until either the player is dead (and the game is lost), or all monsters are dead (and the game is won). The monsters have four characteristics: intelligence, telepathy, tunneling ability, and erraticness. Intelligence allows the monster to understand the fastest path through the dungeon and gives it memory, telepathy gives it the knowledge of where the player is at all times, tunneling ability allows it to mine through rocks, and erraticness makes the monster move randomly half of the time. This program also uses a speed system, where turns are queued in a priority queue based on the character's speed, with the monster having from 5-20, and the player having 10. 

ncursed.c: This program does everything from earlier, but allows direct input for the player to move. It uses all flags as before, and also allows the printing of the monster list with 'm' input, quitting with 'Q', and also allows the player to go up and down staircases. Going up a staircase will generate a new map, keeping the player in the same spot as before. This also ensures that the player will end up in a room instead of stuck in rock. Additionally, when the game ends organically (PC or everyone else dies), ASCII art will be printed to the screen.

rlg327.c: This program is an exact copy of ncursed.c, created for the ease of the grader to know which file to run.


All functions used in each file are split up between multiple headers:

structs.h: contains the three structs used for the dungeon: a room struct, containing its row and col position along with its width and height, an obj struct containing a row and col position, and a dungeon struct, containing an array of rooms, and array of up and down staircases, and the position of the player character.

mapgen.h: contains the functions that generate the dungeon: generate_corridor, which generates a corridor between two given rooms, generate_room, which generates a room with a random position and size, generate_map, which uses the previous 2 functions to populate the dungeon struct, and print_map, which is pretty self-explanatory (it prints the map).

mapsl.h: contains the two functions used for saving and loading: save_map, which saves to a given filepath using the structure outlined in 1.02, and load_map, which loads from the given filepath using the same structure.

priorityq.h: contains the two structs used to make the priority queue, pq_node, a node, and pq_queue, the total queue, and the three functions that manipulate this queue: pq_add, which adds a given row and column of a certain priority to the queue, sorting them from smallest priority to largest, pq_decrease, which takes the node with the given row and column and changes the weight to be higher, moving it down in the queue accordingly, and pq_pop, which returns and removes the node with the smallest priority in the queue.

pathing.h: contains the functions used to create the two paths, weight_nontunnel which gives the map grid weights depending on if there is open space or rocks, weight_tunnel which gives the map grid weights depending on the hardness of each rock, dijkstra, which implements Dijkstra's method, and print_hex_map and print_path, which prints a given grid either in hexadecimal or in modulo 10.

danger.h: implements all methods regarding the monsters: generate_monster, which initializes the monster with a random type, speed, and position, and its memory of the player location is by default empty, line_of_sight, which calculates if the monster has line of sight with the player, kill_monster, which removes the monster from the dungeon, move_pc, which moves the player, and move, which implements all characteristics of the monster to move around the map.

drats.h: implements functions relating to the usage of the ncurses library. This file is called "drats.h" because when a dastardly thing happens to a character in a cartoon, sometimes instead of saying "Curses!" they say "Drats!".

hero.h: implements functions relating to user input: pc_turn, which is ran when it is the player's move and runs based on whatever key they hit. If they input a direction, move_pc is called to move the player in the given direction, outputing an error if they cannot move that way. use_staircase is the last function, which generates a new dungeon around the player when they go up or down a staircase.

ascii.h: contains two different string literal combinations of ascii art stolen from the internet: a tombstone and a treasure chest. Finding out which of these is printed on a loss or a win is an exercise left to the reader.


The makefile will by default build just rlg327.c out of the given programs, and to the TA reading this, they should probably just run ./rlg327 since it implements everything we've done so far in this class.


Special thanks to Christopher Woods (me) for writing this program, Joshua Travelle Harris (not me) for giving me a couple slices of pizza while I finished up assignment 1.02, and Maisy Millage for talking about food while I finished up assignment 1.05, and making me deleriously hungry. Also to ascii.co.uk for not copyright striking me after I steal their art.
