This package includes four programs: mapbuild.c, pathfind.c, mapandpath.c, and monstermap.c.

mapbuild.c: This program generates and prints a 80x21 map based on the specifications given in the assignment 1.01, namely containing at least 6 rooms that are at least 4x3 in size that are all connected by corridors. A random map can be generated by calling the program (./mapgen) without any parameters, and it can also be called with a seed.

This program supports using three flags, any other arguments will throw an error:

--load: This loads the map from a file named "dungeon" in the .rlg327/ directory in the user's home directory. This uses a special file structure outlined in the 1.02 assignment spec, which among other things gives the room grid with rock hardnesses, and room, stairs, and player character locations.

--save: This saves the map that was either generated randomly, generated from a given seed, or loaded from the dungeon file, into the same location that the load_map function loads to.

--seed <seed number>: This gives the map generator a seed to generate from instead of generating randomly. The argument after the --seed flag can be any integer, and if it is negative it will generate randomly.

Any and all of these flags can be used simultaneously, however using --seed in conjunction with --load will render the --seed function useless, as a map isn't being generated. --load and --save together will read the given dungeon file and save a file that will output the exact same dungeon, so it exists more for a "hey did this student do this right so I can give them points" perspective for the TAs reading this file.

pathfind.c: This program loads the map from the "dungeon" file in the .rlg327/ directory in the user's home directory and generates and prints two 80x21 pathing maps. The first one represents the distance from the player character for a nontunneling monster, so walls are impossible to pass through, and moving from each cell takes one unit. The second one represents the distance from the player character from a tunneling monster, so walls take their hardness/85 plus one units to move through, and rooms and corridors take one unit. These maps are calculated using the one and only Dijkstra's method.

mapandpath.c: This program does what both of the previous programs do at once. It can use any and all of the flags that mapbuild.c can, and in addition to printing out the generated/loaded map, will also print out the two pathing maps that pathfind.c generates. It also generates 10 monsters and simulates 20 turns of monster movement.

monstermap.c: This program simulates an actual game, doing what all previous programs do plus game flow. It uses all flags as before plus the --nummons <number> flag, which allows the manual setting of the number of monsters instead of the default 10. This runs the game until either the player is dead (and the game is lost), or all monsters are dead (and the game is won). The monsters have four characteristics: intelligence, telepathy, tunneling ability, and erraticness. Intelligence allows the monster to understand the fastest path through the dungeon and gives it memory, telepathy gives it the knowledge of where the player is at all times, tunneling ability allows it to mine through rocks, and erraticness makes the monster move randomly half of the time. This program also uses a speed system, where turns are queued in a priority queue based on the character's speed, with the monster having from 5-20, and the player having 10. 


All functions used in each file are split up between multiple headers:

structs.h: contains the three structs used for the dungeon: a room struct, containing its row and col position along with its width and height, an obj struct containing a row and col position, and a dungeon struct, containing an array of rooms, and array of up and down staircases, and the position of the player character.

mapgen.h: contains the functions that generate the dungeon: generate_corridor, which generates a corridor between two given rooms, generate_room, which generates a room with a random position and size, generate_map, which uses the previous 2 functions to populate the dungeon struct, and print_map, which is pretty self-explanatory (it prints the map).

mapsl.h: contains the two functions used for saving and loading: save_map, which saves to a given filepath using the structure outlined in 1.02, and load_map, which loads from the given filepath using the same structure.

priorityq.h: contains the two structs used to make the priority queue, pq_node, a node, and pq_queue, the total queue, and the three functions that manipulate this queue: pq_add, which adds a given row and column of a certain priority to the queue, sorting them from smallest priority to largest, pq_decrease, which takes the node with the given row and column and changes the weight to be higher, moving it down in the queue accordingly, and pq_pop, which returns and removes the node with the smallest priority in the queue.

pathing.h: contains the functions used to create the two paths, weight_nontunnel which gives the map grid weights depending on if there is open space or rocks, weight_tunnel which gives the map grid weights depending on the hardness of each rock, dijkstra, which implements Dijkstra's method, and print_hex_map and print_path, which prints a given grid either in hexadecimal or in modulo 10.

priorityq2.h: mostly identical to priorityq.h, except the pop method returns the priority as well, and the data is just a single integer.

danger.h: implements all methods regarding the monsters: generate_monster, which initializes the monster with a random type, speed, and position, and its memory of the player location is by default empty, line_of_sight, which calculates if the monster has line of sight with the player, kill_monster, which removes the monster from the dungeon, move_pc, which moves the player, and move, which implements all characteristics of the monster to move around the map.


The makefile will by default build all four of the given programs, and to the TA reading this, they should probably run ./monstermap since it implements everything we've done so far in this class.


Special thanks to Christopher Woods (me) for writing this program, and Joshua Travelle Harris (not me) for giving me a couple slices of pizza while I finished up assignment 1.02.
