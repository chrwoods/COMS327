This package includes five programs: mapbuild.cpp, pathfind.cpp, ncursed.cpp, testload.cpp, and rlg327.cpp.

mapbuild.cpp: This program generates and prints a 80x21 map based on the specifications given in the assignment 1.01, namely containing at least 6 rooms that are at least 4x3 in size that are all connected by corridors. A random map can be generated by calling the program (./mapgen) without any parameters, and it can also be called with a seed.

This program supports using three flags, any other arguments will throw an error:

--load: This loads the map from a file named "dungeon" in the .rlg327/ directory in the user's home directory. This uses a special file structure outlined in the 1.02 assignment spec, which among other things gives the room grid with rock hardnesses, and room, stairs, and player character locations.

--save: This saves the map that was either generated randomly, generated from a given seed, or loaded from the dungeon file, into the same location that the load_map function loads to.

--seed <seed number>: This gives the map generator a seed to generate from instead of generating randomly. The argument after the --seed flag can be any integer, and if it is negative it will generate randomly.

Any and all of these flags can be used simultaneously, however using --seed in conjunction with --load will render the --seed function useless, as a map isn't being generated. --load and --save together will read the given dungeon file and save a file that will output the exact same dungeon, so it exists more for a "hey did this student do this right so I can give them points" perspective for the TAs reading this file.

pathfind.cpp: This program loads the map from the "dungeon" file in the .rlg327/ directory in the user's home directory and generates and prints two 80x21 pathing maps. The first one represents the distance from the player character for a nontunneling monster, so walls are impossible to pass through, and moving from each cell takes one unit. The second one represents the distance from the player character from a tunneling monster, so walls take their hardness/85 plus one units to move through, and rooms and corridors take one unit. These maps are calculated using the one and only Dijkstra's method.

ncursed.cpp: This program actually runs the game, doing what all previous programs do plus game flow. It uses all flags as before plus the --nummon <number> flag, which allows the manual setting of the number of monsters instead of the default 10. This runs the game until either the player is dead (and the game is lost), or all monsters are dead (and the game is won). The monsters have four characteristics: intelligence, telepathy, tunneling ability, and erraticness. Intelligence allows the monster to understand the fastest path through the dungeon and gives it memory, telepathy gives it the knowledge of where the player is at all times, tunneling ability allows it to mine through rocks, and erraticness makes the monster move randomly half of the time. This program also uses a speed system, where turns are queued in a priority queue based on the character's speed, with the monster having from 5-20, and the player having 10. 

The program allows direct input for the player to move. This includes using the classic roguelike keys to move around, the printing of the monster list with 'm' input, toggling fog of war with 'f', and quitting with 'Q'. Fog of war means that the player can only see in a 5x5 grid around himself plus terrain that he has already seen, so often times monsters will be lurking in the shadows. The player can also go up and down staircases. Going up a staircase will generate a new map, keeping the player in the same spot as before. This also ensures that the player will end up in a room instead of stuck in rock. There is also a teleport feature, activated from the 't' key, which allows the player to select where on the map they would like to teleport, or teleport randomly with the 'r' key. Additionally, when the game ends organically (PC or everyone else dies, not a force quit), ASCII art will be printed to the screen.

testload.cpp: This program demonstrates the parsing of text files for reading in monsters and objects. The exact format for the monsters and items is specified in the assignment 1.07 document, but in short the text file contains a filetype header and then begins each monster with "BEGIN MONSTER" or each object with "BEGIN OBJECT", and then has each aspect of the monster or object as a header of each line, with the value immediately following (i.e. "NAME Libyan in a Van"). Once all values are initialized, there is a line just containing "END", signifying the end of that monster/object. Once every monster/object is loaded into its vector, it is then printed out to the console in a *slightly* different format so that the TAs know that I didn't just read and print out the file without parsing it like some kind of .txt parrot. This program will load and print all the monsters, then immediately load and print all the items. 

rlg327.cpp: This program is an exact copy of testload.cpp, created for the ease of the grader to know which file to run.


All functions used in each file are split up between multiple headers:

classes.h: contains the six classes used for the dungeon: Room, containing its row and col position along with its width and height, Obj containing a row and col position, Monster, containing a position, the remembered PC position, and all of its other attributes detailed in 1.07, Item, containing a position and all of the attributes detailed in 1.07, Dice, containing the number of dice, the number of sides, and a baseline value, along with a few helper functions to convert back and forth from a string to these three numbers, and Dungeon, containing an array of rooms, and array of up and down staircases, the position of the player character, a vector of monsters, a vector of items, a stored character grid of all the terrain, a character grid of the terrain that the PC remembers, and a boolean grid to see what the PC can currently see.

mapgen.h: contains the functions that generate the dungeon: generate_corridor, which generates a corridor between two given rooms, generate_room, which generates a room with a random position and size, generate_map, which uses the previous 2 functions to populate the dungeon struct, generate_map_around_pc, which instead generates a map around where the player character is right now (used for staircases) and old_print_map, which is deprecated and allows printing of the map through good old printf instead of our fancy new ncurses.

mapsl.h: contains the two functions used for saving and loading: save_map, which saves to a given filepath using the structure outlined in 1.02, and load_map, which loads from the given filepath using the same structure.

priorityq.h: contains the two classes used to make the priority queue, PQ_node, a node, and PQueue, the total queue, and the four functions that manipulate this queue: add, which adds a datum of a certain priority to the queue, sorting them from smallest priority to largest, decrease, which takes the node with the given datum and changes the weight, moving it up or down in the queue accordingly, pop, which returns and removes the node with the smallest priority in the queue, and peek, which returns the top of the queue without removing it.

pathing.h: contains the functions used to create the two paths, weight_nontunnel which gives the map grid weights depending on if there is open space or rocks, weight_tunnel which gives the map grid weights depending on the hardness of each rock, dijkstra, which implements Dijkstra's method, and print_path, which prints a given grid either in modulo 10.

danger.h: implements all methods regarding the monsters: generate_monster, which initializes the monster with a random type, speed, and position, and its memory of the player location is by default empty, line_of_sight, which calculates if the monster has line of sight with the player using Bresenham's line algorithm (this assumes the monsters have 100/20 vision), kill_monster, which removes the monster from the dungeon, and move_monster, which implements all characteristics of the monster to move around the map, and if it is visible, updates it on the screen.

drats.h: implements functions relating to the usage of the ncurses library. This file is called "drats.h" because when a dastardly thing happens to a character in a cartoon, sometimes instead of saying "Curses!" they say "Drats!". These functions are drats, which initializes ncurses, update_background, which reads all the terrain, rooms, and stairs into a background grid, update_fog, which updates the remembered terrain and visibility based on where the PC is, print_fog, which prints the map using remembered terrain, print_map, which prints the map using the actual map terrain, stard, which shuts down ncurses, and update_status_text, which prints error messages directly under the map. This header also contains all the constants used for the coloring of objects in the dungeon.

hero.h: implements functions relating to user input: pc_turn, which is ran when it is the player's move and runs based on whatever key they hit. If they input a direction, move_pc is called to move the player in the given direction, outputing an error if they cannot move that way. Inputting a '<' or a '>' calls use_staircase, which generates a new dungeon around the player when they go up or down a staircase. Inputting 'f' toggles the fog of war when the dungeon is printed, and inputting 't' calls the last function, teleport, which lets the player move around a '*' pointer around the map using the directional keys, and hit 't' again to teleport there, or 'r' to teleport somewhere random.

ascii.h: contains two different string literal combinations of ascii art stolen from the internet: a tombstone and a treasure chest. Finding out which of these is printed on a loss or a win is an exercise left to the reader.

loader.h: contains the functions to load monsters and items from text files: load_monsters(), which loads monsters from a given filepath to a text file using the load_monster() helper function, which loads a single monster, parsing from a block of text from "BEGIN MONSTER" to "END", and inserts it into the monster vector. load_items() and load_item() work in a very similar fashion, only instead of loading monsters it loads items (duh).


The makefile will by default build only rlg327.cpp out of the given programs, and to the TA reading this, they should probably just run ./rlg327 since it implements everything we've done so far in this class.


Special thanks to Christopher Woods (me) for writing this program, Joshua Travelle Harris (not me) for giving me a couple slices of pizza while I finished up assignment 1.02, and Maisy Millage for talking about food while I finished up assignment 1.05, and making me deliriously hungry. Also to ascii.co.uk for not copyright striking me after I steal their art.
